### Короткий опис архітектурного підходу

#### 1) Організація компонентів
- Шари та призначення:
  - `app/` — маршрути, макети (`layout.tsx`), ініціалізація провайдерів, глобальні стилі.
  - `components/` — UI-бібліотека та бізнес-компоненти:
    - `components/ui/*` — дрібні, перевикористовувані, «безлогічні» (presentational) компоненти: кнопки, інпути, картки, іконки. Без знання домену, без доступу до глобального стану.
    - `components/features/*` — композиції UI навколо конкретної фічі (наприклад, селект локації, слайдер кількості). Мінімум бізнес-логіки, максимум інкапсуляції UX.
    - `components/layout/*` — шапка, сайдбар, контейнери сторінок.
    - `components/pages/*` — сторінкові композиції (glue‑компоненти), які з’єднують фічі між собою.
- Патерни повторного використання:
  - «Лего-підхід»: дрібні `ui`-атомики + легкі хелпери (`utils`) + фічеві обгортки.
  - Проп‑дрил мінімізується через локальний стан і контексти (тільки там, де є реальна потреба в широкому споживанні стану).
  - Додатково: колекції констант і словників у `lib/*`, типи — у відповідних `lib/*.ts`.

#### 2) Робота з API у масштабному проєкті
- Рівні абстракції:
  - `lib/api/client.ts` — інстанс axios/fetch з базовим URL, таймаутами, авторизаційними хедерами та глобальною обробкою помилок.
  - `lib/api/services/*` — сервіси для конкретних ресурсів (наприклад, `orders`, `auth`) з чіткими методами.
  - `hooks/*` — кастомні хуки (`useOrders`, `useAuth`) для компонентів, часто з React Query/SWR для кешування і повторних запитів.
- Типізація та безпека:
  - Всі відповіді API типізуються через TypeScript, що мінімізує помилки та робить код передбачуваним.
- Глобальна обробка помилок:
  - Централізована обробка 401/403 та показ дружніх повідомлень користувачу.
- Переваги:
  - Легка масштабованість, можливість швидко додавати нові ресурси та підтримувати чистий код у великому проєкті.

#### 3) Масштабування сторінок і функціональності
- Файлова модульність: кожна фіча живе в окремій папці (`components/features/<feature>`), має свої `index.tsx`, локальні хук(и) та стилі. Загальні частини виносимо в `components/ui` і `lib`.
- Інкрементальне додавання блоків: нові блоки — як окремі фічі, які підключаються у сторінковий контейнер (`components/pages/*`). Мінімальна кількість глобального стану, щоб зменшити зчеплення.
- Продуктивність: мемоізація (React Compiler + `useMemo`/`useCallback` у вузьких місцях), розумний спліт коду (динамічний імпорт рідкісних віджетів), серверні обчислення там, де можливо.
- Дизайн‑система: консолідація токенів у Tailwind (кольори, відступи, типографіка) і бібліотека `ui`‑компонентів забезпечують консистентність і швидкість розробки.

#### 4) Основні ризики фронтенда
- Роздутий глобальний стан і зайва крос‑фіче залежність → повільні ререндери, складність супроводу. Міграція до локальних контекстів/селекторів, дизайн state‑ownership.
- Невалідовані контракти API → «крихкий» runtime. Вирішується схемами валідації, типогенерацією (OpenAPI → TS типи), e2e‑контрактами.
- A11y і i18n як afterthought → дорогі переробки. Вбудовувати з першого дня: семантика, `aria`‑атрибути, тестування клавіатурою, централізований словник.
- Перфоманс на низьких девайсах: важкі списки/графіка. Віртуалізація списків, lazy‑loading, пріоритезація ресурсів, вимірювання (Web Vitals, профайлер).
- Розсинхронізація бізнес‑правил у різних шарах (UI/сервер/клієнтські утиліти). Єдине джерело істини в `lib` (правила/розрахунки), покриті тестами.

